# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
> Через mongo-shell:
> 1. Получить id текущего запроса с помощью: `db.currentOp()`
> 2. Далее, через `db.killOp()` завершить запрос полученный на шаге 1.
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB
> Через `maxTimeMS()` ограничить таймаут запроса по истечению которого он завершится
> подобно `db.killOp()`
> 
> Например: 
> 
> db.location.find( { "town": { "$regex": "(Pine Lumber)",
                              "$options": 'i' } } ).maxTimeMS(30)
## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?
>  При добавлении ноды, мы нактнулись на [maxmemory](https://redis.io/docs/getting-started/faq/#what-happens-if-redis-runs-out-of-memory)
>
> Согласно [доке](https://redis.io/docs/reference/optimization/latency/#latency-generated-by-expires) если кол-во
> истекших ключей в одну и ту же секунду больше чем 25% от общего набора ключей,
> Redis заблокирует возможность записи.
>
>P.S. Было бы здорово если бы проверяющий дал более практичный и развернутый комментарий.
 
## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?


> 4 возможных причины происходящего:
> - Проблемы с сетевой подсистемой - проверить на хосте пропускную способность, ошибки CRC и т.д.
> - Запросили слишком много(миллион) строк - если это необходимо, то нужно увеличить `net_read_timeout`(по умолчанию 30s) 
> - Клиент не успевает установить соединение из-за параметра `connect_timeout` - если слишком
> большое расстояние или медленное соединение, можно попробовать увеличть параметр `connect_timeout`
> до оптимального. Можно проверить с помощью SHOW GLOBAL STATUS LIKE 'Aborted_connects'
> - Проблема с [BLOB](https://dev.mysql.com/doc/refman/8.0/en/blob.html) который больше чем параметр 
> `max_allowed_packet` - попробовать увеличить данный параметр.


## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

> oom-killer - Out-Of-Memory Killer - процесс который завершает приложение(в нашем случае postgres),
> которое пытается занять всю свободную RAM, для того что-бы спасти ядро от kernel panic.

Как бы вы решили данную проблему?

> Один из способ добавить `echo vm.overcommit_memory = 2 >> /etc/sysctl.conf
> Ядро не отдаст в резерв больше памяти чем указано в `overcommit_ratio`
> (процент памяти для которого допустимо избыточное резервирование)
> 
> Но самый правильный способ, на мой взгляд, ограничить потребление памяти 
> через postgresql.conf, используя следующий директивы:
> `shared_buffers`
> `work_mem`
> `maintenance_work_mem`
> `effective_cache_size`

> P.S. хорошая [статья](https://habr.com/ru/company/southbridge/blog/464245/) на память.
> 
> Еще хорошая [статья](https://www.enterprisedb.com/postgres-tutorials/how-tune-postgresql-memory) по тюнингу RAM.
---

